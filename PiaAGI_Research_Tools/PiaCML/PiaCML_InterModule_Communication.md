# PiaCML Inter-Module Communication Specification

## 1. Introduction and Goals

### Purpose
A standardized inter-module communication system is essential for the PiaAGI framework to ensure:
*   **Modularity:** Modules can be developed, tested, and updated independently.
*   **Interoperability:** Different implementations of a module interface can seamlessly connect with other modules.
*   **Debuggability:** Clear message flows make it easier to trace information and identify issues.
*   **Scalability:** A well-defined system can better accommodate a growing number of modules and more complex interactions.
*   **Clarity:** Standardized messages and protocols improve the overall understanding of the system's dynamics.

### High-Level Design Goals
*   **Clarity & Simplicity:** Message structures and protocols should be easy to understand and implement.
*   **Efficiency:** Communication should not impose undue overhead, especially for high-frequency interactions.
*   **Extensibility:** The system must allow for easy addition of new message types and modules without requiring major overhauls.
*   **Flexibility:** Support various interaction patterns (e.g., request/response, publish/subscribe) as needed by different modules.
*   **Decoupling:** Minimize direct dependencies between modules, promoting loose coupling.

## 2. Communication Paradigm

### Chosen Paradigm
A **hybrid approach combining an Asynchronous Message Bus (or Event Bus) with standardized Direct API Calls** for specific, tightly coupled interactions is proposed.

*   **Message Bus / Event Bus:** This will be the primary mechanism for most inter-module communication. Modules can publish messages (events) to the bus, and other interested modules can subscribe to specific message types. This promotes decoupling and flexibility.
*   **Direct API Calls:** For performance-critical or very specific request-response interactions where the overhead of a message bus might be undesirable (e.g., a quick query from Working Memory to a utility function within LTM for data formatting), direct method invocation on a module's interface can be allowed, but should be used judiciously.

### Rationale
*   **Message Bus Benefits:**
    *   **Loose Coupling:** Publishers and subscribers don't need direct knowledge of each other.
    *   **Scalability:** Easy to add new publishers or subscribers.
    *   **Flexibility:** Supports various communication patterns (pub/sub, targeted messages if the bus allows).
    *   **Asynchronous Nature:** Allows modules to operate concurrently without blocking, crucial for a responsive AGI.
*   **Direct API Call Benefits:**
    *   **Lower Latency:** Can be faster for specific, well-defined interactions.
    *   **Simplicity for Tight Coupling:** Easier for cases where two modules are inherently closely linked for a specific function.

### Basic Protocol
*   **Primary Mode (Message Bus): Asynchronous Publish/Subscribe.**
    *   Modules register with the message bus, declaring which message types they can publish and which they wish to subscribe to.
    *   When a module publishes a message, the bus routes it to all subscribed modules.
*   **Secondary Mode (Direct API): Synchronous Request/Response (typically).**
    *   Used for specific, pre-defined interface methods.
*   **Message Identification:** Each message type will have a unique identifier (e.g., a string name like "PerceptDataAvailable" or "LTMQueryRequest").

## 3. Core Message/Data Structures

### Generic Message Wrapper
All messages passed through the message bus will be encapsulated in a generic wrapper to provide common context:

```
GenericMessage {
    message_id: UUID          // Unique ID for this specific message instance
    source_module_id: String  // Identifier of the module sending the message
    target_module_id: String  // Optional: Identifier of a specific target module (for directed messages on the bus, if supported) or "BROADCAST"
    message_type: String      // E.g., "PerceptData", "LTMQuery"
    timestamp: DateTime       // Timestamp of message creation (UTC)
    payload: Object           // The actual specific message data (e.g., PerceptData object)
    metadata: Dict            // Optional: For routing tags, priority, or other bus-specific info
}
```

### Specific Inter-Module Message Structures

1.  **`PerceptData`**
    *   **Purpose:** To carry structured information from Perception modules to other modules (e.g., Working Memory, World Model).
    *   **`message_type`**: "PerceptData"
    *   **Payload Fields:**
        *   `percept_id`: UUID // Unique ID for this piece of percept data
        *   `modality`: String // E.g., "text_input", "visual_scene_graph", "audio_features"
        *   `content`: Any // The actual data (e.g., string for text, JSON for scene graph)
        *   `source_timestamp`: DateTime // When the percept was captured/generated by the sensor/source
        *   `processing_timestamp`: DateTime // When the Perception module finished processing this data
        *   `metadata`: Dict // Optional: E.g., confidence scores, sensor ID, preliminary classifications

2.  **`LTMQuery`**
    *   **Purpose:** For any module to request information from a Long-Term Memory module.
    *   **`message_type`**: "LTMQuery"
    *   **Payload Fields:**
        *   `query_id`: UUID // Unique ID for this query, to correlate with LTMQueryResult
        *   `requester_module_id`: String // Module that initiated the query
        *   `query_type`: String // E.g., "semantic_search", "episodic_retrieval_by_cue", "pattern_completion", "knowledge_graph_traversal"
        *   `query_content`: Any // The substance of the query (e.g., search terms, cues, graph path)
        *   `target_memory_type`: String // Optional: E.g., "semantic", "episodic", "procedural" (if LTM is structured this way)
        *   `parameters`: Dict // Optional: E.g., `max_results`, `similarity_threshold`, `time_range_for_episodic`

3.  **`LTMQueryResult`**
    *   **Purpose:** For an LTM module to return information in response to an `LTMQuery`.
    *   **`message_type`**: "LTMQueryResult"
    *   **Payload Fields:**
        *   `query_id`: UUID // Corresponds to the `query_id` from the `LTMQuery`
        *   `results`: List[MemoryItem] // List of retrieved memory items. `MemoryItem` itself would be a structured object (e.g., content, metadata, timestamps, associations)
        *   `success_status`: Boolean // True if query was successful, False otherwise
        *   `error_message`: String // Optional: Description of error if `success_status` is False
        *   `metadata`: Dict // Optional: E.g., number of results, confidence scores for results

4.  **`GoalUpdate`**
    *   **Purpose:** For the Motivational System to communicate new, updated, or completed goals to other relevant modules (e.g., Planning, Self-Model).
    *   **`message_type`**: "GoalUpdate"
    *   **Payload Fields:**
        *   `goal_id`: UUID // Unique ID for the goal
        *   `goal_description`: String // Textual description of the goal
        *   `priority`: Float // Numerical priority (e.g., 0.0 to 1.0)
        *   `status`: String // E.g., "new", "active", "achieved", "failed", "suspended", "updated"
        *   `originator`: String // E.g., "intrinsic_curiosity", "extrinsic_user_command", "self_preservation_drive"
        *   `criteria_for_completion`: String // Description of what constitutes achievement
        *   `associated_rewards_penalties`: Dict // Optional: Expected rewards or penalties
        *   `deadline`: DateTime // Optional: Goal deadline

5.  **`EmotionalStateChange`**
    *   **Purpose:** For the Emotion Module to broadcast updates about the agent's current emotional state.
    *   **`message_type`**: "EmotionalStateChange"
    *   **Payload Fields:**
        *   `current_emotion_profile`: Dict // E.g., `{"valence": 0.7, "arousal": 0.5, "dominance": 0.6}` or `{"joy": 0.8, "sadness": 0.1}`
        *   `primary_emotion`: String // Optional: Dominant discrete emotion, if applicable (e.g., "joy")
        *   `intensity`: Float // Overall intensity of the emotional state
        *   `triggering_event_id`: UUID // Optional: ID of the event/message/percept that primarily triggered this change
        *   `behavioral_impact_suggestions`: List[String] // Optional: E.g., ["increase_caution", "seek_information"]

6.  **`ActionCommand`**
    *   **Purpose:** For the Planning/Decision-Making module to send a command to a Behavior Generation or Actuator module.
    *   **`message_type`**: "ActionCommand"
    *   **Payload Fields:**
        *   `command_id`: UUID // Unique ID for this command
        *   `action_type`: String // E.g., "linguistic_output", "tool_use_request", "internal_state_adjustment", "navigation_target"
        *   `target_object_or_agent`: String // Optional: Identifier for the target of the action
        *   `parameters`: Dict // Specific parameters for the action (e.g., for linguistic_output: `{"text": "Hello!"}`, for tool_use_request: `{"tool_name": "calculator", "inputs": [2,2]}`)
        *   `expected_outcome_summary`: String // Brief description of what this action is intended to achieve
        *   `priority`: Float // Priority of this action

## 4. Interaction Patterns (Examples)

1.  **Perception to LTM Query:**
    *   `PerceptionModule` processes sensory input and publishes a `PerceptData` message (e.g., recognized text from user input).
    *   `WorkingMemoryModule` subscribes to `PerceptData`. Upon receiving it, it might decide more context is needed.
    *   `WorkingMemoryModule` formulates an `LTMQuery` (e.g., asking for related past interactions or semantic information about entities in the percept) and publishes it.
    *   `LongTermMemoryModule` subscribes to `LTMQuery`. It processes the query.
    *   `LongTermMemoryModule` publishes an `LTMQueryResult` containing the retrieved information.
    *   `WorkingMemoryModule` subscribes to `LTMQueryResult` and integrates the results.

2.  **New Goal Leads to Action:**
    *   `MotivationalSystemModule` identifies a new high-priority goal (e.g., based on an internal drive or external request).
    *   `MotivationalSystemModule` publishes a `GoalUpdate` message with status "new" and high priority.
    *   `PlanningAndDecisionMakingModule` subscribes to `GoalUpdate` messages. Upon receiving a new, high-priority goal, it starts its planning process.
    *   `PlanningAndDecisionMakingModule`, after formulating a plan, publishes one or more `ActionCommand` messages.
    *   `BehaviorGenerationModule` (or specific actuator modules) subscribes to `ActionCommand` messages and executes the specified actions.
    *   Upon action completion (or failure), `BehaviorGenerationModule` might publish an `ActionEvent` (another message type, not detailed above) which could be picked up by Planning, Self-Model, or LTM.

## 5. Extensibility and Future Considerations

*   **Adding New Message Types:**
    *   Define the new message payload structure (similar to those in Section 3).
    *   Assign a unique `message_type` string.
    *   Update relevant modules to publish or subscribe to this new message type.
    *   The `GenericMessage` wrapper remains the same.
*   **Versioning:** As message structures evolve, a versioning system for payload schemas might be necessary (e.g., `message_type_v2`). This can be included in the `GenericMessage.metadata` or as part of the `message_type` string.
*   **Service Discovery:** For more complex scenarios, a service discovery mechanism could allow modules to dynamically find out about other modules and the message types they handle.
*   **Quality of Service (QoS):** The message bus implementation could offer different QoS levels (e.g., guaranteed delivery, best effort) for different message types, potentially managed via `GenericMessage.metadata`.
*   **Security and Permissions:** In multi-agent or externally exposed systems, message validation and module permissions for publishing/subscribing to certain topics might be needed.

---
This document provides a foundational specification. Details will be refined as PiaCML module implementations progress.
---
