from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

class PlanningAndDecisionMakingModule(ABC):
    """
    Abstract Base Class for the Planning and Decision-Making Module in the PiaAGI Cognitive Architecture.

    This module is responsible for higher-level cognitive functions involving evaluating
    potential courses of action, forming plans to achieve goals, and making choices
    among alternatives. It integrates information from various sources including the
    World Model (current state, predictions), Motivational System (active goals),
    Perception Module (environmental cues), and Emotion Module (affective biases).

    The module employs various strategies, from simple heuristic-based choices to
    complex multi-step planning and deliberation, depending on the context and stakes.

    Refer to PiaAGI.md Sections 4.1.8 (Planning and Decision-Making Module) and
    4.4 (Action Selection and Execution) for more detailed context.
    """

    @abstractmethod
    def generate_plans(self, goal: Dict, current_state_summary: Dict, world_model_interface: Any, constraints: Optional[Dict] = None) -> List[Dict]:
        """
        Generates one or more potential plans to achieve a given goal.

        A plan consists of a sequence of actions or sub-goals. This process may involve
        accessing knowledge from the World Model about action outcomes and environmental dynamics.

        Args:
            goal (Dict): The goal to be achieved (e.g., from Motivational System).
                         Example: {'id': 'g1', 'type': 'achieve_state', 'target_state': {...}}
            current_state_summary (Dict): A summary of the current relevant state from Working Memory or World Model.
            world_model_interface (Any): An interface or handle to query the World Model for predictions,
                                         simulations, or knowledge relevant to planning.
            constraints (Optional[Dict]): Any constraints on planning (e.g., time limits, resource limits, forbidden actions).

        Returns:
            List[Dict]: A list of potential plans. Each plan is a structured representation
                        (e.g., a list of action steps, a policy graph).
                        Example Plan: [{'plan_id': 'p1', 'steps': [{'action': 'A', 'params': {}}, {'action': 'B'}], 'expected_utility': 0.8}]
        """
        pass

    @abstractmethod
    def evaluate_plans(self, plans: List[Dict], evaluation_criteria: Dict, world_model_interface: Any) -> List[Dict]:
        """
        Evaluates the generated plans based on specified criteria.

        Criteria might include likelihood of success, estimated cost/effort, time to completion,
        risks involved, alignment with ethical guidelines, emotional impact. This may involve
        simulating plan execution using the World Model.

        Args:
            plans (List[Dict]): The list of plans generated by `generate_plans`.
            evaluation_criteria (Dict): Criteria for evaluation.
                                        Example: {'primary': 'likelihood_of_success', 'secondary': 'minimize_cost',
                                                  'risk_threshold': 0.3}
            world_model_interface (Any): An interface to the World Model for predictive evaluation.


        Returns:
            List[Dict]: The list of plans, augmented with evaluation scores.
                        Example Plan (evaluated): {'plan_id': 'p1', ..., 'scores': {'success_prob': 0.85, 'cost': 10}}
        """
        pass

    @abstractmethod
    def select_best_plan(self, evaluated_plans: List[Dict], selection_strategy: str = "highest_expected_utility") -> Optional[Dict]:
        """
        Selects the best plan from the evaluated list based on a selection strategy.

        Args:
            evaluated_plans (List[Dict]): Plans with their evaluation scores.
            selection_strategy (str): The strategy to use for selection (e.g., "highest_expected_utility",
                                      "satisficing", "risk_adjusted_utility").
        Returns:
            Optional[Dict]: The selected plan, or None if no suitable plan is found.
        """
        pass
    
    @abstractmethod
    def make_decision(self, decision_context: Dict, options: List[Dict], world_model_interface: Any) -> Dict:
        """
        Makes a decision in a specific context, often when full planning is not required or feasible.

        This could involve choosing from a set of discrete options based on current goals,
        emotional state, and predicted outcomes.

        Args:
            decision_context (Dict): Information about the decision to be made, including current goals
                                     and situational factors.
                                     Example: {'type': 'resource_allocation', 'available_resources': 100}
            options (List[Dict]): A list of available options or actions.
                                  Example Option: {'id': 'opt1', 'description': 'Allocate 50 units', 'expected_outcome': {...}}
            world_model_interface (Any): Interface to World Model for evaluating options.


        Returns:
            Dict: The chosen option and rationale.
                  Example: {'chosen_option_id': 'opt1', 'confidence': 0.7, 'reasoning': 'Best utility'}
        """
        pass

    @abstractmethod
    def monitor_plan_execution(self, active_plan_id: str, execution_feedback: Dict, world_model_interface: Any) -> Optional[Dict]:
        """
        Monitors the execution of the active plan and determines if replanning is necessary.

        Args:
            active_plan_id (str): The ID of the currently executing plan.
            execution_feedback (Dict): Feedback from the Behavior Generation Module or Perception
                                       about the outcome of the last action or changes in the environment.
                                       Example: {'action_outcome': 'success', 'new_percept': {...}}
                                       Example: {'action_outcome': 'failure', 'reason': 'obstacle_detected'}
            world_model_interface (Any): Interface to World Model for state updates and predictions.

        Returns:
            Optional[Dict]: A directive if replanning is needed (e.g., {'replan_needed': True, 'reason': 'unexpected_obstacle'})
                            or None if execution is on track.
        """
        pass

    @abstractmethod
    def request_information_for_planning(self, information_query: Dict, target_module_hint: Optional[str] = None) -> Any:
        """
        Requests specific information from other modules (e.g., World Model, LTM)
        that is necessary for planning or decision-making.

        Args:
            information_query (Dict): Specifies the information needed.
                                      Example: {'type': 'predict_action_outcome', 'action': 'A', 'current_state': {...}}
                                      Example: {'type': 'retrieve_past_plan_success_rate', 'goal_type': 'X'}
            target_module_hint (Optional[str]): A hint to which module this query might be best directed
                                                (e.g., "WorldModel", "LongTermMemory").
        Returns:
            Any: The requested information, or an acknowledgement of the request.
        """
        pass

    @abstractmethod
    def get_status(self) -> Dict:
        """
        Returns the current operational status of the Planning and Decision-Making Module.

        Could include information like current planning mode (e.g., deliberative, reactive),
        number of active plans, computational load.

        Returns:
            Dict: Status information.
        """
        pass

if __name__ == '__main__':
    # Conceptual illustration for PlanningAndDecisionMakingModule

    # Dummy World Model Interface for illustration
    class DummyWorldModel:
        def predict_outcome(self, action: str, state: Dict) -> Dict:
            if action == "ActionA": return {"new_state": {**state, "A_done": True}, "success_prob": 0.9, "cost": 5}
            if action == "ActionB": return {"new_state": {**state, "B_done": True}, "success_prob": 0.7, "cost": 8}
            return {"new_state": state, "success_prob": 0.5, "cost": 1}
        
        def get_knowledge(self, query: str) -> Any:
            if query == "resource_availability": return {"energy": 100}
            return None

    class ConceptualPlanner(PlanningAndDecisionMakingModule):
        def __init__(self, world_model: DummyWorldModel):
            self.world_model = world_model
            self.active_plans = {}
            print("ConceptualPlanner initialized.")

        def generate_plans(self, goal: Dict, current_state_summary: Dict, world_model_interface: Any, constraints: Optional[Dict] = None) -> List[Dict]:
            print(f"ConceptualPlanner: Generating plans for goal '{goal.get('id')}' from state {current_state_summary}")
            plans = []
            # Simplified plan generation: sequence of 1 or 2 actions
            if goal.get('target_state', {}).get("A_done") and not current_state_summary.get("A_done"):
                plans.append({'plan_id': 'pA', 'steps': [{'action': 'ActionA'}], 'goal_id': goal.get('id')})
            if goal.get('target_state', {}).get("B_done") and not current_state_summary.get("B_done"):
                 plans.append({'plan_id': 'pB', 'steps': [{'action': 'ActionB'}], 'goal_id': goal.get('id')})
            if goal.get('target_state', {}).get("A_done") and goal.get('target_state', {}).get("B_done") and \
               not (current_state_summary.get("A_done") and current_state_summary.get("B_done")):
                if not current_state_summary.get("A_done"):
                    plans.append({'plan_id': 'pAB', 'steps': [{'action': 'ActionA'}, {'action': 'ActionB'}], 'goal_id': goal.get('id')})
                elif not current_state_summary.get("B_done"): # A is done, only B needed
                     plans.append({'plan_id': 'pB_after_A', 'steps': [{'action': 'ActionB'}], 'goal_id': goal.get('id')})


            print(f"  Generated plans: {[p['plan_id'] for p in plans]}")
            return plans

        def evaluate_plans(self, plans: List[Dict], evaluation_criteria: Dict, world_model_interface: Any) -> List[Dict]:
            print(f"ConceptualPlanner: Evaluating plans with criteria {evaluation_criteria}")
            evaluated = []
            for plan in plans:
                total_cost = 0
                overall_success_prob = 1.0
                temp_state = {} # In a real scenario, this would be based on current_state_summary
                for step in plan['steps']:
                    outcome = world_model_interface.predict_outcome(step['action'], temp_state)
                    total_cost += outcome['cost']
                    overall_success_prob *= outcome['success_prob']
                    temp_state = outcome['new_state']
                
                plan['scores'] = {'success_prob': overall_success_prob, 'cost': total_cost}
                # Utility could be success_prob / cost or something more complex
                plan['expected_utility'] = overall_success_prob / (total_cost + 0.1) # avoid div by zero
                evaluated.append(plan)
                print(f"  Evaluated plan {plan['plan_id']}: {plan['scores']}, Utility: {plan['expected_utility']:.2f}")
            return evaluated
        
        def select_best_plan(self, evaluated_plans: List[Dict], selection_strategy: str = "highest_expected_utility") -> Optional[Dict]:
            print(f"ConceptualPlanner: Selecting best plan using strategy: {selection_strategy}")
            if not evaluated_plans: return None
            if selection_strategy == "highest_expected_utility":
                best = max(evaluated_plans, key=lambda p: p.get('expected_utility', 0))
                print(f"  Selected plan: {best['plan_id']} with utility {best['expected_utility']:.2f}")
                return best
            return evaluated_plans[0] # Default to first

        def make_decision(self, decision_context: Dict, options: List[Dict], world_model_interface: Any) -> Dict:
            print(f"ConceptualPlanner: Making decision for context: {decision_context}")
            # Simplified: pick option with highest 'value' if present
            best_option = max(options, key=lambda o: o.get('value', 0)) if options else None
            print(f"  Chosen option: {best_option.get('id') if best_option else 'None'}")
            return {'chosen_option_id': best_option.get('id') if best_option else None, 'confidence': 0.9}


        def monitor_plan_execution(self, active_plan_id: str, execution_feedback: Dict, world_model_interface: Any) -> Optional[Dict]:
            print(f"ConceptualPlanner: Monitoring plan '{active_plan_id}'. Feedback: {execution_feedback}")
            if execution_feedback.get('action_outcome') == 'failure':
                print(f"  Plan '{active_plan_id}' encountered failure. Replanning needed.")
                return {'replan_needed': True, 'reason': execution_feedback.get('reason', 'unknown_failure')}
            # Further checks could be done here, e.g. if state deviates too much
            return None

        def request_information_for_planning(self, information_query: Dict, target_module_hint: Optional[str] = None) -> Any:
            print(f"ConceptualPlanner: Requesting information: {information_query} (Hint: {target_module_hint})")
            if target_module_hint == "WorldModel" and information_query.get('type') == 'get_knowledge':
                return self.world_model.get_knowledge(information_query.get('query_key'))
            return "Information not available through this conceptual path."

        def get_status(self) -> Dict:
            return {"module_type": "ConceptualPlanner", "active_plans_count": len(self.active_plans), "load": "normal"}

    # Conceptual usage:
    dummy_wm = DummyWorldModel()
    planner = ConceptualPlanner(world_model=dummy_wm)

    goal1 = {'id': 'g1', 'type': 'achieve_state', 'target_state': {'A_done': True, 'B_done': True}}
    current_state = {'A_done': False, 'B_done': False}
    
    # Test information request
    resources = planner.request_information_for_planning(
        {'type': 'get_knowledge', 'query_key': 'resource_availability'}, 
        target_module_hint="WorldModel"
    )
    print(f"Available resources: {resources}")

    plans = planner.generate_plans(goal1, current_state, dummy_wm)
    evaluated_plans = planner.evaluate_plans(plans, {'primary': 'success_prob', 'secondary': 'cost'}, dummy_wm)
    best_plan = planner.select_best_plan(evaluated_plans)

    if best_plan:
        print(f"Executing plan: {best_plan['plan_id']}")
        planner.active_plans[best_plan['plan_id']] = best_plan
        
        # Simulate execution feedback
        feedback_success = {'action_outcome': 'success', 'new_percept': {'A_done': True}}
        monitoring_result = planner.monitor_plan_execution(best_plan['plan_id'], feedback_success, dummy_wm)
        if monitoring_result:
            print(f"Monitoring indicates: {monitoring_result}")

        feedback_failure = {'action_outcome': 'failure', 'reason': 'unexpected_obstacle'}
        monitoring_result = planner.monitor_plan_execution(best_plan['plan_id'], feedback_failure, dummy_wm)
        if monitoring_result:
            print(f"Monitoring indicates: {monitoring_result}")

    decision_options = [
        {'id': 'opt_X', 'description': 'Choose X', 'value': 10},
        {'id': 'opt_Y', 'description': 'Choose Y', 'value': 20}
    ]
    decision = planner.make_decision({'type': 'simple_choice'}, decision_options, dummy_wm)
    print(f"Made decision: {decision}")
    
    print(f"Planner status: {planner.get_status()}")

```
